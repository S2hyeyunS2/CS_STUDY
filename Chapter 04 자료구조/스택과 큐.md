## 📦 스택 (Stack)

> 스택은 데이터를 **차곡차곡 쌓았다가, 나중에 넣은 걸 먼저 꺼내는 구조**

### ✔️ 쉽게 말하면

- 스택은 **상자 쌓기**처럼 위로 쌓아 올린 다음 **맨 위에서 꺼내는 방식**
- 나중에 넣은 것이 먼저 나오는 구조 
  👉 **LIFO (Last In, First Out) 후입선출**

### 📷 시각 자료  
![스택](https://github.com/user-attachments/assets/eaac796e-60c0-453d-a0d7-25da4a5129d8)

*(위에 넣고, 위에서 꺼냄)*

---

### ✅ 사용 예시

| 상황                            | 설명                                  |
|----------------------------------|----------------------------------------|
| 웹 브라우저 '뒤로 가기' 기능     | 최근 방문 페이지부터 거꾸로 돌아감     |
| 엑셀에서 실행 취소(Undo)        | 최근 작업부터 되돌림                   |
| 재귀 함수 호출                  | 함수 호출이 쌓이고 거꾸로 처리됨       |


- 최근에 임시 저장한 데이터를 가장 먼저 활용해야 할 때
- 뒤로가기 기능을 만들고 싶을 때
  
---

### 🧑‍💻 Python 코드 예시 (스택)

```python
stack = []

# 값 넣기 (push)
stack.append('A')
stack.append('B')
stack.append('C')

# 값 꺼내기 (pop)
print(stack.pop())  # C

# 현재 상태 확인
print(stack)  # ['A', 'B']
```

---

### 🧪 시간 복잡도

| 작업        | 시간 복잡도 |
|-------------|--------------|
| 삽입 (push) | O(1)         |
| 삭제 (pop)  | O(1)         |
| 조회 (peek) | O(1)         |

### ✅ 특징 요약

| 항목   | 설명                                  |
|--------|----------------------------------------|
| 구조   | 위에서만 넣고 빼는 단일 출입구         |
| 방식   | LIFO (Last In, First Out)              |
| 장점   | 구현이 간단하고 빠름                  |
| 단점   | 중간 데이터를 직접 접근할 수 없음     |

---

## 🚌 큐 (Queue)

> 큐는 **한 쪽으로 데이터를 삽입하고, 다른 한쪽으로 데이터를 삭제하는** 자료구조

### ✔️ 쉽게 말하면

- 큐는 **버스 정류장 줄서기**와 같음  
  앞에 줄 선 사람이 먼저 탐
  👉 **FIFO (First In, First Out) 선입선출** 구조

### 📷 시각 자료  
![큐](https://github.com/user-attachments/assets/e4c8efa2-c260-4e16-98d7-f5c91e27fc92)

*(앞에서 빠지고, 뒤에 새로 들어감)*

---

### ✅ 사용 예시

| 상황             | 설명                                      |
|------------------|-------------------------------------------|
| 은행 번호표      | 먼저 뽑은 사람이 먼저 상담 받음            |
| 프린터 대기열    | 먼저 보낸 문서가 먼저 인쇄됨               |
| CPU 작업 처리    | 작업을 순서대로 처리                       |

---

### 🧑‍💻 Python 코드 예시 (큐)

```python
from collections import deque

queue = deque()

# 값 넣기 (enqueue)
queue.append('A')
queue.append('B')
queue.append('C')

# 값 꺼내기 (dequeue)
print(queue.popleft())  # A

# 현재 상태 확인
print(queue)  # deque(['B', 'C'])
```

---

### 🧪 시간 복잡도

| 작업           | 시간 복잡도 |
|----------------|--------------|
| 삽입 (enqueue) | O(1)         |
| 삭제 (dequeue) | O(1)         |
| 조회 (peek)    | O(1)         |

### ✅ 특징 요약

| 항목   | 설명                                  |
|--------|----------------------------------------|
| 구조   | 앞에서 꺼내고 뒤에서 넣는 구조        |
| 방식   | FIFO (First In, First Out)             |
| 장점   | 순서대로 처리해야 할 작업에 적합      |
| 단점   | 특정 위치 접근이 어려움               |

---

### ✅ 스택 vs 큐 비교

| 항목        | 스택 (Stack)           | 큐 (Queue)               |
|-------------|------------------------|--------------------------|
| 동작 원리   | LIFO (후입선출)         | FIFO (선입선출)           |
| 삽입 위치   | 위에 넣음 (push)        | 뒤에 넣음 (enqueue)       |
| 제거 위치   | 위에서 꺼냄 (pop)       | 앞에서 꺼냄 (dequeue)      |
| 사용 예시   | 실행 취소, 함수 호출    | 작업 대기열, 고객 처리     |

---

## 🔁 원형 큐 (Circular Queue)

> 원형 큐는 **맨 뒤까지 가면 다시 처음으로 돌아가는 구조**의 큐

---

### ✔️ 쉽게 말하면

- 일반 큐는 **한 방향으로만 이동**해서 공간이 금방 다 참
- 원형 큐는 **끝까지 가면 다시 앞쪽 빈 공간을 재활용**
- 마치 **회전하는 놀이기구 좌석처럼** 한 바퀴 돌아 다시 처음으로 가는 구조

### 📷 시각 자료  
![원형 큐큐](https://github.com/user-attachments/assets/c6f601fa-36d8-4ffe-9f33-94f05c6f3aa2)

*(마지막 → 처음으로 연결된 모습)*

---

### ✅ 사용 예시

| 상황                   | 설명                                 |
|------------------------|--------------------------------------|
| 고정된 크기의 버퍼     | 일정 용량을 반복 재사용할 때 유용함  |
| 멀티태스킹 시스템      | CPU 시간 분배용 Round-Robin 스케줄링 |

---

### 🧑‍💻 Python 코드 예시 (원형 큐 구현 예)

```python
class CircularQueue:
    def __init__(self, size):
        self.queue = [None] * size
        self.size = size
        self.front = 0
        self.rear = 0

    def enqueue(self, item):
        if (self.rear + 1) % self.size == self.front:
            print("Queue is full!")
            return
        self.queue[self.rear] = item
        self.rear = (self.rear + 1) % self.size

    def dequeue(self):
        if self.front == self.rear:
            print("Queue is empty!")
            return None
        item = self.queue[self.front]
        self.front = (self.front + 1) % self.size
        return item

# 사용 예시
cq = CircularQueue(5)
cq.enqueue("A")
cq.enqueue("B")
cq.enqueue("C")
print(cq.dequeue())  # A
```

---

### 🧪 시간 복잡도

| 작업           | 시간 복잡도 |
|----------------|--------------|
| 삽입 (enqueue) | O(1)         |
| 삭제 (dequeue) | O(1)         |

### ✅ 특징 요약

| 항목   | 설명                                      |
|--------|-------------------------------------------|
| 구조   | 끝 → 처음으로 이어지는 순환 구조          |
| 장점   | 고정된 공간에서 반복 사용 가능            |
| 단점   | 구현이 일반 큐보다 복잡함                 |

---

## 🔄 양방향 큐 (Deque)

> Deque(덱)는 **양쪽 끝에서 삽입과 삭제가 모두 가능한 큐**  
> 이름은 "Double Ended Queue"의 줄임말

---

### ✔️ 쉽게 말하면

- 앞에서도 넣고, 뒤에서도 넣을 수 있음
- 앞에서도 꺼내고, 뒤에서도 꺼낼 수 있음
- **스택과 큐의 장점**을 모두 가진 자료구조

---

### 📷 시각 자료  
![](https://github.com/user-attachments/assets/6b243ed0-8c84-42b4-a1f8-69f1eaa9b1e7)
 
*(앞뒤로 자유롭게 추가/삭제 가능)*

---

### ✅ 사용 예시

| 상황                         | 설명                                     |
|------------------------------|------------------------------------------|
| 앞뒤로 데이터를 처리할 때    | 예: 팰린드롬 검사, 텍스트 편집기 캐시      |
| 양쪽에서 요청이 들어올 때    | 예: 양방향 네트워크 패킷 처리, 윈도우 캐시 등 |

---

### 🧑‍💻 Python 코드 예시 (deque 사용)

```python
from collections import deque

dq = deque()

# 뒤에서 삽입
dq.append('A')
dq.append('B')

# 앞에서 삽입
dq.appendleft('C')

# 앞에서 삭제
dq.popleft()  # C

# 뒤에서 삭제
dq.pop()      # B

print(dq)  # deque(['A'])
```

---

### 🧪 시간 복잡도

| 작업                  | 시간 복잡도 |
|-----------------------|--------------|
| 앞/뒤 삽입            | O(1)         |
| 앞/뒤 삭제            | O(1)         |
| 특정 위치 접근        | O(n)         |

### ✅ 특징 요약

| 항목   | 설명                                       |
|--------|--------------------------------------------|
| 구조   | 앞뒤 양쪽 끝 모두 삽입/삭제 가능           |
| 장점   | 스택 + 큐 역할 모두 가능                   |
| 단점   | 중간 위치 직접 접근은 느림 (`O(n)`)         |

---

## 🎯 우선순위 큐 (Priority Queue)

> **우선순위 큐**는 데이터마다 우선순위를 부여하고,  
> **가장 높은 우선순위를 가진 요소부터 꺼내는 자료구조**

### ✔️ 쉽게 말하면

- 일반 큐는 먼저 넣은 순서대로 꺼내지만,  
  **우선순위 큐는 중요도(우선순위)가 높은 것부터 꺼냄**
- 마치 **응급실**처럼, 먼저 온 순서보다 **환자의 상태가 더 중요**한 구조

---

### 📷 시각 자료  
![우선순위 큐](https://github.com/user-attachments/assets/7b5fe21c-fecd-4a06-947e-eff9fb42706d)

*(높은 우선순위부터 먼저 처리됨)*

---

### ✅ 사용 예시

| 상황                           | 설명                                               |
|--------------------------------|----------------------------------------------------|
| 운영체제 스케줄링              | CPU가 먼저 중요한 작업부터 처리                   |
| 네트워크 트래픽 처리           | 긴급 패킷이 일반 패킷보다 먼저 전송됨             |
| 게임 AI 행동 우선순위 결정     | 가장 중요한 행동(예: 회피, 공격)을 먼저 수행       |
| 다익스트라 알고리즘            | 가장 짧은 거리 노드를 먼저 탐색                   |

---

### 🧑‍💻 Python 코드 예시 (우선순위 큐 with `heapq`)

```python
import heapq

# (우선순위, 값) 형식으로 튜플 저장
pq = []
heapq.heappush(pq, (3, '일반'))
heapq.heappush(pq, (1, '긴급'))
heapq.heappush(pq, (2, '보통'))

# 우선순위가 낮은 숫자일수록 먼저 나옴
while pq:
    priority, task = heapq.heappop(pq)
    print(f"{task} (우선순위 {priority})")
```

---

### 🧪 시간 복잡도

| 작업                 | 시간 복잡도     |
|----------------------|------------------|
| 삽입 (enqueue)       | O(log n)         |
| 삭제 (dequeue)       | O(log n)         |
| 최대/최소 조회       | O(1)             |

### ✅ 특징 요약

| 항목   | 설명                                               |
|--------|----------------------------------------------------|
| 구조   | 우선순위에 따라 정렬되는 큐                        |
| 방식   | 우선순위가 높은 요소부터 꺼냄                      |
| 장점   | 중요도 기반으로 효율적인 작업 처리 가능           |
| 단점   | 일반 큐보다 구현이 복잡하고 속도가 느릴 수 있음   |

